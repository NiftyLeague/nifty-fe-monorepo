/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from 'ethers6';
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from '../../../common';

export declare namespace NFTLRaffle {
  export type WinnerInfoStruct = {
    ticketId: BigNumberish;
    winner: AddressLike;
    prizeTokenId: BigNumberish;
  };

  export type WinnerInfoStructOutput = [ticketId: bigint, winner: string, prizeTokenId: bigint] & {
    ticketId: bigint;
    winner: string;
    prizeTokenId: bigint;
  };
}

export interface NFTLRaffleInterface extends Interface {
  getFunction(
    nameOrSignature:
      | 'NFTL_AMOUNT_FOR_TICKET'
      | 'allowUserDeposit'
      | 'assignTicketToUsers'
      | 'cancelSubscription'
      | 'chargeLINK'
      | 'currentWinnerTicketCount'
      | 'deposit'
      | 'depositPrizeNFT'
      | 'disallowUserDeposit'
      | 'distributeTicketsToCitadelKeyHolders'
      | 'distributeTicketsToUsers'
      | 'getRandomWordsList'
      | 'getUserCount'
      | 'getUserList'
      | 'getWinners'
      | 'initialize'
      | 'isTicketAssignedToUsers'
      | 'isUserDepositAllowed'
      | 'isWinnerTicketId'
      | 'manageConsumers'
      | 'nftl'
      | 'onERC721Received'
      | 'owner'
      | 'pause'
      | 'paused'
      | 'prizeNFT'
      | 'prizeNFTTokenIndex'
      | 'prizeNFTokenIds'
      | 'raffleStartAt'
      | 'randomWordList'
      | 'rawFulfillRandomWords'
      | 'renounceOwnership'
      | 'requestRandomWordsForWinnerSelection'
      | 's_subscriptionId'
      | 'ticketCountByUser'
      | 'ticketIdList'
      | 'ticketRangeByUser'
      | 'totalTicketCount'
      | 'totalWinnerTicketCount'
      | 'transferOwnership'
      | 'unpause'
      | 'updateTotalWinnerTicketCount'
      | 'userByTicketId'
      | 'userDeposits'
      | 'winners'
      | 'withdrawLINK',
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | 'Initialized'
      | 'OwnershipTransferred'
      | 'Paused'
      | 'RandomWordsReceived'
      | 'RandomWordsRequested'
      | 'TicketDistributed'
      | 'Unpaused'
      | 'UserDeposited'
      | 'WinnerSelected',
  ): EventFragment;

  encodeFunctionData(functionFragment: 'NFTL_AMOUNT_FOR_TICKET', values?: undefined): string;
  encodeFunctionData(functionFragment: 'allowUserDeposit', values?: undefined): string;
  encodeFunctionData(functionFragment: 'assignTicketToUsers', values?: undefined): string;
  encodeFunctionData(functionFragment: 'cancelSubscription', values?: undefined): string;
  encodeFunctionData(functionFragment: 'chargeLINK', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'currentWinnerTicketCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'deposit', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'depositPrizeNFT', values: [BigNumberish[]]): string;
  encodeFunctionData(functionFragment: 'disallowUserDeposit', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'distributeTicketsToCitadelKeyHolders',
    values: [AddressLike[], BigNumberish[]],
  ): string;
  encodeFunctionData(functionFragment: 'distributeTicketsToUsers', values: [AddressLike[], BigNumberish[]]): string;
  encodeFunctionData(functionFragment: 'getRandomWordsList', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getUserCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getUserList', values?: undefined): string;
  encodeFunctionData(functionFragment: 'getWinners', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [AddressLike, BigNumberish, BigNumberish, AddressLike, AddressLike],
  ): string;
  encodeFunctionData(functionFragment: 'isTicketAssignedToUsers', values?: undefined): string;
  encodeFunctionData(functionFragment: 'isUserDepositAllowed', values?: undefined): string;
  encodeFunctionData(functionFragment: 'isWinnerTicketId', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'manageConsumers', values: [AddressLike, boolean]): string;
  encodeFunctionData(functionFragment: 'nftl', values?: undefined): string;
  encodeFunctionData(
    functionFragment: 'onERC721Received',
    values: [AddressLike, AddressLike, BigNumberish, BytesLike],
  ): string;
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
  encodeFunctionData(functionFragment: 'pause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string;
  encodeFunctionData(functionFragment: 'prizeNFT', values?: undefined): string;
  encodeFunctionData(functionFragment: 'prizeNFTTokenIndex', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'prizeNFTokenIds', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'raffleStartAt', values?: undefined): string;
  encodeFunctionData(functionFragment: 'randomWordList', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'rawFulfillRandomWords', values: [BigNumberish, BigNumberish[]]): string;
  encodeFunctionData(functionFragment: 'renounceOwnership', values?: undefined): string;
  encodeFunctionData(functionFragment: 'requestRandomWordsForWinnerSelection', values?: undefined): string;
  encodeFunctionData(functionFragment: 's_subscriptionId', values?: undefined): string;
  encodeFunctionData(functionFragment: 'ticketCountByUser', values: [AddressLike]): string;
  encodeFunctionData(functionFragment: 'ticketIdList', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'ticketRangeByUser', values: [AddressLike]): string;
  encodeFunctionData(functionFragment: 'totalTicketCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'totalWinnerTicketCount', values?: undefined): string;
  encodeFunctionData(functionFragment: 'transferOwnership', values: [AddressLike]): string;
  encodeFunctionData(functionFragment: 'unpause', values?: undefined): string;
  encodeFunctionData(functionFragment: 'updateTotalWinnerTicketCount', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'userByTicketId', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'userDeposits', values: [AddressLike]): string;
  encodeFunctionData(functionFragment: 'winners', values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: 'withdrawLINK', values: [AddressLike]): string;

  decodeFunctionResult(functionFragment: 'NFTL_AMOUNT_FOR_TICKET', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'allowUserDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'assignTicketToUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'cancelSubscription', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'chargeLINK', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'currentWinnerTicketCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'depositPrizeNFT', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'disallowUserDeposit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'distributeTicketsToCitadelKeyHolders', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'distributeTicketsToUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getRandomWordsList', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getUserCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getUserList', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'getWinners', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isTicketAssignedToUsers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isUserDepositAllowed', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isWinnerTicketId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'manageConsumers', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'nftl', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'onERC721Received', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'pause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'prizeNFT', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'prizeNFTTokenIndex', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'prizeNFTokenIds', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'raffleStartAt', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'randomWordList', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'rawFulfillRandomWords', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'renounceOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'requestRandomWordsForWinnerSelection', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 's_subscriptionId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ticketCountByUser', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ticketIdList', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'ticketRangeByUser', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalTicketCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'totalWinnerTicketCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'transferOwnership', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'unpause', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'updateTotalWinnerTicketCount', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userByTicketId', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'userDeposits', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'winners', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'withdrawLINK', data: BytesLike): Result;
}

export namespace InitializedEvent {
  export type InputTuple = [version: BigNumberish];
  export type OutputTuple = [version: bigint];
  export interface OutputObject {
    version: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace OwnershipTransferredEvent {
  export type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
  export type OutputTuple = [previousOwner: string, newOwner: string];
  export interface OutputObject {
    previousOwner: string;
    newOwner: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RandomWordsReceivedEvent {
  export type InputTuple = [requestId: BigNumberish, randomWords: BigNumberish[]];
  export type OutputTuple = [requestId: bigint, randomWords: bigint[]];
  export interface OutputObject {
    requestId: bigint;
    randomWords: bigint[];
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RandomWordsRequestedEvent {
  export type InputTuple = [requestId: BigNumberish, randomCountToRequest: BigNumberish];
  export type OutputTuple = [requestId: bigint, randomCountToRequest: bigint];
  export interface OutputObject {
    requestId: bigint;
    randomCountToRequest: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TicketDistributedEvent {
  export type InputTuple = [to: AddressLike, ticketCount: BigNumberish];
  export type OutputTuple = [to: string, ticketCount: bigint];
  export interface OutputObject {
    to: string;
    ticketCount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UnpausedEvent {
  export type InputTuple = [account: AddressLike];
  export type OutputTuple = [account: string];
  export interface OutputObject {
    account: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UserDepositedEvent {
  export type InputTuple = [user: AddressLike, nftlAmount: BigNumberish];
  export type OutputTuple = [user: string, nftlAmount: bigint];
  export interface OutputObject {
    user: string;
    nftlAmount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WinnerSelectedEvent {
  export type InputTuple = [by: AddressLike, winner: AddressLike, ticketId: BigNumberish, prizeTokenId: BigNumberish];
  export type OutputTuple = [by: string, winner: string, ticketId: bigint, prizeTokenId: bigint];
  export interface OutputObject {
    by: string;
    winner: string;
    ticketId: bigint;
    prizeTokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface NFTLRaffle extends BaseContract {
  connect(runner?: ContractRunner | null): NFTLRaffle;
  waitForDeployment(): Promise<this>;

  interface: NFTLRaffleInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>,
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;

  NFTL_AMOUNT_FOR_TICKET: TypedContractMethod<[], [bigint], 'view'>;

  allowUserDeposit: TypedContractMethod<[], [void], 'nonpayable'>;

  assignTicketToUsers: TypedContractMethod<[], [void], 'nonpayable'>;

  cancelSubscription: TypedContractMethod<[], [void], 'nonpayable'>;

  chargeLINK: TypedContractMethod<[_amount: BigNumberish], [void], 'nonpayable'>;

  currentWinnerTicketCount: TypedContractMethod<[], [bigint], 'view'>;

  deposit: TypedContractMethod<[_amount: BigNumberish], [void], 'nonpayable'>;

  depositPrizeNFT: TypedContractMethod<[_prizeNFTTokenIds: BigNumberish[]], [void], 'nonpayable'>;

  disallowUserDeposit: TypedContractMethod<[], [void], 'nonpayable'>;

  distributeTicketsToCitadelKeyHolders: TypedContractMethod<
    [_holders: AddressLike[], _keyCount: BigNumberish[]],
    [void],
    'nonpayable'
  >;

  distributeTicketsToUsers: TypedContractMethod<
    [_users: AddressLike[], _ticketCount: BigNumberish[]],
    [void],
    'nonpayable'
  >;

  getRandomWordsList: TypedContractMethod<[], [bigint[]], 'view'>;

  getUserCount: TypedContractMethod<[], [bigint], 'view'>;

  getUserList: TypedContractMethod<[], [string[]], 'view'>;

  getWinners: TypedContractMethod<[], [NFTLRaffle.WinnerInfoStructOutput[]], 'view'>;

  initialize: TypedContractMethod<
    [
      _nftl: AddressLike,
      _pendingPeriod: BigNumberish,
      _totalWinnerTicketCount: BigNumberish,
      _prizeNFT: AddressLike,
      _vrfCoordinator: AddressLike,
    ],
    [void],
    'nonpayable'
  >;

  isTicketAssignedToUsers: TypedContractMethod<[], [boolean], 'view'>;

  isUserDepositAllowed: TypedContractMethod<[], [boolean], 'view'>;

  isWinnerTicketId: TypedContractMethod<[arg0: BigNumberish], [boolean], 'view'>;

  manageConsumers: TypedContractMethod<[_consumer: AddressLike, _add: boolean], [void], 'nonpayable'>;

  nftl: TypedContractMethod<[], [string], 'view'>;

  onERC721Received: TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish, arg3: BytesLike],
    [string],
    'nonpayable'
  >;

  owner: TypedContractMethod<[], [string], 'view'>;

  pause: TypedContractMethod<[], [void], 'nonpayable'>;

  paused: TypedContractMethod<[], [boolean], 'view'>;

  prizeNFT: TypedContractMethod<[], [string], 'view'>;

  prizeNFTTokenIndex: TypedContractMethod<[arg0: BigNumberish], [bigint], 'view'>;

  prizeNFTokenIds: TypedContractMethod<[arg0: BigNumberish], [bigint], 'view'>;

  raffleStartAt: TypedContractMethod<[], [bigint], 'view'>;

  randomWordList: TypedContractMethod<[arg0: BigNumberish], [bigint], 'view'>;

  rawFulfillRandomWords: TypedContractMethod<
    [_requestId: BigNumberish, _randomWords: BigNumberish[]],
    [void],
    'nonpayable'
  >;

  renounceOwnership: TypedContractMethod<[], [void], 'nonpayable'>;

  requestRandomWordsForWinnerSelection: TypedContractMethod<[], [bigint], 'nonpayable'>;

  s_subscriptionId: TypedContractMethod<[], [bigint], 'view'>;

  ticketCountByUser: TypedContractMethod<[arg0: AddressLike], [bigint], 'view'>;

  ticketIdList: TypedContractMethod<[arg0: BigNumberish], [bigint], 'view'>;

  ticketRangeByUser: TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, bigint] & { startTicketId: bigint; endTicketId: bigint }],
    'view'
  >;

  totalTicketCount: TypedContractMethod<[], [bigint], 'view'>;

  totalWinnerTicketCount: TypedContractMethod<[], [bigint], 'view'>;

  transferOwnership: TypedContractMethod<[newOwner: AddressLike], [void], 'nonpayable'>;

  unpause: TypedContractMethod<[], [void], 'nonpayable'>;

  updateTotalWinnerTicketCount: TypedContractMethod<[_totalWinnerTicketCount: BigNumberish], [void], 'nonpayable'>;

  userByTicketId: TypedContractMethod<[arg0: BigNumberish], [string], 'view'>;

  userDeposits: TypedContractMethod<[arg0: AddressLike], [bigint], 'view'>;

  winners: TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, bigint] & {
        ticketId: bigint;
        winner: string;
        prizeTokenId: bigint;
      },
    ],
    'view'
  >;

  withdrawLINK: TypedContractMethod<[_to: AddressLike], [void], 'nonpayable'>;

  getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

  getFunction(nameOrSignature: 'NFTL_AMOUNT_FOR_TICKET'): TypedContractMethod<[], [bigint], 'view'>;
  getFunction(nameOrSignature: 'allowUserDeposit'): TypedContractMethod<[], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'assignTicketToUsers'): TypedContractMethod<[], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'cancelSubscription'): TypedContractMethod<[], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'chargeLINK'): TypedContractMethod<[_amount: BigNumberish], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'currentWinnerTicketCount'): TypedContractMethod<[], [bigint], 'view'>;
  getFunction(nameOrSignature: 'deposit'): TypedContractMethod<[_amount: BigNumberish], [void], 'nonpayable'>;
  getFunction(
    nameOrSignature: 'depositPrizeNFT',
  ): TypedContractMethod<[_prizeNFTTokenIds: BigNumberish[]], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'disallowUserDeposit'): TypedContractMethod<[], [void], 'nonpayable'>;
  getFunction(
    nameOrSignature: 'distributeTicketsToCitadelKeyHolders',
  ): TypedContractMethod<[_holders: AddressLike[], _keyCount: BigNumberish[]], [void], 'nonpayable'>;
  getFunction(
    nameOrSignature: 'distributeTicketsToUsers',
  ): TypedContractMethod<[_users: AddressLike[], _ticketCount: BigNumberish[]], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'getRandomWordsList'): TypedContractMethod<[], [bigint[]], 'view'>;
  getFunction(nameOrSignature: 'getUserCount'): TypedContractMethod<[], [bigint], 'view'>;
  getFunction(nameOrSignature: 'getUserList'): TypedContractMethod<[], [string[]], 'view'>;
  getFunction(nameOrSignature: 'getWinners'): TypedContractMethod<[], [NFTLRaffle.WinnerInfoStructOutput[]], 'view'>;
  getFunction(
    nameOrSignature: 'initialize',
  ): TypedContractMethod<
    [
      _nftl: AddressLike,
      _pendingPeriod: BigNumberish,
      _totalWinnerTicketCount: BigNumberish,
      _prizeNFT: AddressLike,
      _vrfCoordinator: AddressLike,
    ],
    [void],
    'nonpayable'
  >;
  getFunction(nameOrSignature: 'isTicketAssignedToUsers'): TypedContractMethod<[], [boolean], 'view'>;
  getFunction(nameOrSignature: 'isUserDepositAllowed'): TypedContractMethod<[], [boolean], 'view'>;
  getFunction(nameOrSignature: 'isWinnerTicketId'): TypedContractMethod<[arg0: BigNumberish], [boolean], 'view'>;
  getFunction(
    nameOrSignature: 'manageConsumers',
  ): TypedContractMethod<[_consumer: AddressLike, _add: boolean], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'nftl'): TypedContractMethod<[], [string], 'view'>;
  getFunction(
    nameOrSignature: 'onERC721Received',
  ): TypedContractMethod<
    [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish, arg3: BytesLike],
    [string],
    'nonpayable'
  >;
  getFunction(nameOrSignature: 'owner'): TypedContractMethod<[], [string], 'view'>;
  getFunction(nameOrSignature: 'pause'): TypedContractMethod<[], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'paused'): TypedContractMethod<[], [boolean], 'view'>;
  getFunction(nameOrSignature: 'prizeNFT'): TypedContractMethod<[], [string], 'view'>;
  getFunction(nameOrSignature: 'prizeNFTTokenIndex'): TypedContractMethod<[arg0: BigNumberish], [bigint], 'view'>;
  getFunction(nameOrSignature: 'prizeNFTokenIds'): TypedContractMethod<[arg0: BigNumberish], [bigint], 'view'>;
  getFunction(nameOrSignature: 'raffleStartAt'): TypedContractMethod<[], [bigint], 'view'>;
  getFunction(nameOrSignature: 'randomWordList'): TypedContractMethod<[arg0: BigNumberish], [bigint], 'view'>;
  getFunction(
    nameOrSignature: 'rawFulfillRandomWords',
  ): TypedContractMethod<[_requestId: BigNumberish, _randomWords: BigNumberish[]], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'renounceOwnership'): TypedContractMethod<[], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'requestRandomWordsForWinnerSelection'): TypedContractMethod<[], [bigint], 'nonpayable'>;
  getFunction(nameOrSignature: 's_subscriptionId'): TypedContractMethod<[], [bigint], 'view'>;
  getFunction(nameOrSignature: 'ticketCountByUser'): TypedContractMethod<[arg0: AddressLike], [bigint], 'view'>;
  getFunction(nameOrSignature: 'ticketIdList'): TypedContractMethod<[arg0: BigNumberish], [bigint], 'view'>;
  getFunction(
    nameOrSignature: 'ticketRangeByUser',
  ): TypedContractMethod<
    [arg0: AddressLike],
    [[bigint, bigint] & { startTicketId: bigint; endTicketId: bigint }],
    'view'
  >;
  getFunction(nameOrSignature: 'totalTicketCount'): TypedContractMethod<[], [bigint], 'view'>;
  getFunction(nameOrSignature: 'totalWinnerTicketCount'): TypedContractMethod<[], [bigint], 'view'>;
  getFunction(nameOrSignature: 'transferOwnership'): TypedContractMethod<[newOwner: AddressLike], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'unpause'): TypedContractMethod<[], [void], 'nonpayable'>;
  getFunction(
    nameOrSignature: 'updateTotalWinnerTicketCount',
  ): TypedContractMethod<[_totalWinnerTicketCount: BigNumberish], [void], 'nonpayable'>;
  getFunction(nameOrSignature: 'userByTicketId'): TypedContractMethod<[arg0: BigNumberish], [string], 'view'>;
  getFunction(nameOrSignature: 'userDeposits'): TypedContractMethod<[arg0: AddressLike], [bigint], 'view'>;
  getFunction(nameOrSignature: 'winners'): TypedContractMethod<
    [arg0: BigNumberish],
    [
      [bigint, string, bigint] & {
        ticketId: bigint;
        winner: string;
        prizeTokenId: bigint;
      },
    ],
    'view'
  >;
  getFunction(nameOrSignature: 'withdrawLINK'): TypedContractMethod<[_to: AddressLike], [void], 'nonpayable'>;

  getEvent(
    key: 'Initialized',
  ): TypedContractEvent<InitializedEvent.InputTuple, InitializedEvent.OutputTuple, InitializedEvent.OutputObject>;
  getEvent(
    key: 'OwnershipTransferred',
  ): TypedContractEvent<
    OwnershipTransferredEvent.InputTuple,
    OwnershipTransferredEvent.OutputTuple,
    OwnershipTransferredEvent.OutputObject
  >;
  getEvent(
    key: 'Paused',
  ): TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
  getEvent(
    key: 'RandomWordsReceived',
  ): TypedContractEvent<
    RandomWordsReceivedEvent.InputTuple,
    RandomWordsReceivedEvent.OutputTuple,
    RandomWordsReceivedEvent.OutputObject
  >;
  getEvent(
    key: 'RandomWordsRequested',
  ): TypedContractEvent<
    RandomWordsRequestedEvent.InputTuple,
    RandomWordsRequestedEvent.OutputTuple,
    RandomWordsRequestedEvent.OutputObject
  >;
  getEvent(
    key: 'TicketDistributed',
  ): TypedContractEvent<
    TicketDistributedEvent.InputTuple,
    TicketDistributedEvent.OutputTuple,
    TicketDistributedEvent.OutputObject
  >;
  getEvent(
    key: 'Unpaused',
  ): TypedContractEvent<UnpausedEvent.InputTuple, UnpausedEvent.OutputTuple, UnpausedEvent.OutputObject>;
  getEvent(
    key: 'UserDeposited',
  ): TypedContractEvent<UserDepositedEvent.InputTuple, UserDepositedEvent.OutputTuple, UserDepositedEvent.OutputObject>;
  getEvent(
    key: 'WinnerSelected',
  ): TypedContractEvent<
    WinnerSelectedEvent.InputTuple,
    WinnerSelectedEvent.OutputTuple,
    WinnerSelectedEvent.OutputObject
  >;

  filters: {
    'Initialized(uint8)': TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;
    Initialized: TypedContractEvent<
      InitializedEvent.InputTuple,
      InitializedEvent.OutputTuple,
      InitializedEvent.OutputObject
    >;

    'OwnershipTransferred(address,address)': TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;
    OwnershipTransferred: TypedContractEvent<
      OwnershipTransferredEvent.InputTuple,
      OwnershipTransferredEvent.OutputTuple,
      OwnershipTransferredEvent.OutputObject
    >;

    'Paused(address)': TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;
    Paused: TypedContractEvent<PausedEvent.InputTuple, PausedEvent.OutputTuple, PausedEvent.OutputObject>;

    'RandomWordsReceived(uint256,uint256[])': TypedContractEvent<
      RandomWordsReceivedEvent.InputTuple,
      RandomWordsReceivedEvent.OutputTuple,
      RandomWordsReceivedEvent.OutputObject
    >;
    RandomWordsReceived: TypedContractEvent<
      RandomWordsReceivedEvent.InputTuple,
      RandomWordsReceivedEvent.OutputTuple,
      RandomWordsReceivedEvent.OutputObject
    >;

    'RandomWordsRequested(uint256,uint256)': TypedContractEvent<
      RandomWordsRequestedEvent.InputTuple,
      RandomWordsRequestedEvent.OutputTuple,
      RandomWordsRequestedEvent.OutputObject
    >;
    RandomWordsRequested: TypedContractEvent<
      RandomWordsRequestedEvent.InputTuple,
      RandomWordsRequestedEvent.OutputTuple,
      RandomWordsRequestedEvent.OutputObject
    >;

    'TicketDistributed(address,uint256)': TypedContractEvent<
      TicketDistributedEvent.InputTuple,
      TicketDistributedEvent.OutputTuple,
      TicketDistributedEvent.OutputObject
    >;
    TicketDistributed: TypedContractEvent<
      TicketDistributedEvent.InputTuple,
      TicketDistributedEvent.OutputTuple,
      TicketDistributedEvent.OutputObject
    >;

    'Unpaused(address)': TypedContractEvent<
      UnpausedEvent.InputTuple,
      UnpausedEvent.OutputTuple,
      UnpausedEvent.OutputObject
    >;
    Unpaused: TypedContractEvent<UnpausedEvent.InputTuple, UnpausedEvent.OutputTuple, UnpausedEvent.OutputObject>;

    'UserDeposited(address,uint256)': TypedContractEvent<
      UserDepositedEvent.InputTuple,
      UserDepositedEvent.OutputTuple,
      UserDepositedEvent.OutputObject
    >;
    UserDeposited: TypedContractEvent<
      UserDepositedEvent.InputTuple,
      UserDepositedEvent.OutputTuple,
      UserDepositedEvent.OutputObject
    >;

    'WinnerSelected(address,address,uint256,uint256)': TypedContractEvent<
      WinnerSelectedEvent.InputTuple,
      WinnerSelectedEvent.OutputTuple,
      WinnerSelectedEvent.OutputObject
    >;
    WinnerSelected: TypedContractEvent<
      WinnerSelectedEvent.InputTuple,
      WinnerSelectedEvent.OutputTuple,
      WinnerSelectedEvent.OutputObject
    >;
  };
}
